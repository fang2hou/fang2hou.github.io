<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>C++ on 方舟</title><link>https://fang2hou.com/tags/c++/</link><description>Recent content in C++ on 方舟</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Sat, 13 Nov 2021 16:54:40 +0900</lastBuildDate><atom:link href="https://fang2hou.com/tags/c++/index.xml" rel="self" type="application/rss+xml"/><item><title>由 C++ 入门 Rust 05（结构体）</title><link>https://fang2hou.com/post/cpp-to-rust-05/</link><pubDate>Sat, 13 Nov 2021 16:54:40 +0900</pubDate><guid>https://fang2hou.com/post/cpp-to-rust-05/</guid><description>结构体，老生常谈的编程语言概念了。本文就不多做基本介绍，直击一些 Rust 的特殊用法或是写法。
基本写法 struct User { username: String, email: String, sign_in_count: u64, active: bool, } 如上所示，这是一个简单到不能再简单的 User 结构体。我们可以通过指定字段对其进行修改。</description></item><item><title>由 C++ 入门 Rust 04（切片）</title><link>https://fang2hou.com/post/cpp-to-rust-04/</link><pubDate>Mon, 13 Sep 2021 16:54:40 +0900</pubDate><guid>https://fang2hou.com/post/cpp-to-rust-04/</guid><description>前言 在上一篇文章中，我们已经可以认识到 Rust 对于资源所有权的设计非常的独特，但是在实际使用中，对于很多数据，我们需要的仅仅是其中一小段，或是一个。为了很小的需求而获取了完整的资源所有权，这不免有些小题大做了。Rust 对于这类情况，导入了切片概念。一起来了解一下吧~
切片 切片，我第一次接触到是在 Go 语言之中，不同于复制数组重新构成一个对象或是结构体，切片是在内存上进行操作的。简单来说，切片可以在一份数据保存在内存上的情况下，提供了不同范围的访问。因此，切片是非常高效的一种数据使用方法。
但是由于是同一份数据，切片对应的内存上如果数据被清除，创造出的切片自然也无法继续存续了。Rust 提供了极佳的所有权机制，在所有权机制下，这个现象理解起来相比于别的语言学习者，想必是非常轻松的。</description></item><item><title>由 C++ 入门 Rust 03（拷贝，所有权及引用）</title><link>https://fang2hou.com/post/cpp-to-rust-03/</link><pubDate>Sat, 04 Sep 2021 11:01:00 +0900</pubDate><guid>https://fang2hou.com/post/cpp-to-rust-03/</guid><description>前言 拷贝问题，或者说拷贝背后的实现在大部分编程语言中的表现都是存在差异的。Rust 在拷贝上采用了较为少见的所有权机制。作为学习的一环，下面我会使用一些小例子进行简单的说明解释。
拷贝 种类 在看代码前，首先要复习一下深拷贝和浅拷贝的区别。
深拷贝：其实这是最直观的拷贝形式，将拷贝对象持有的全部信息数据都执行拷贝操作，然后产生一个完全独立的对象。特点为修改深拷贝后的对象数据不会作用于原对象。
浅拷贝：浅拷贝对于一些常见的，特别是存放在栈上的数据采用完全拷贝字面量的操作。但是对于对象，则只会拷贝对象的数据指针，属性等。特点之与深拷贝，操作浅拷贝后的对象会同时作用于之前的对象。
代码 1 fn main() { let x = 1; let y = x; print(&amp;quot;{}&amp;quot;, x); // 1 print(&amp;quot;{}&amp;quot;, y); // 1 } 这段代码是非常简洁易懂的，即程序拷贝 x 到 y。在这里 x 是被自动推断为了 i32 类型，属于指定大小的类型而不是对象，那么理应被存于栈中。上面分类中也有提到，对于这类变量，拷贝都是直接复制字面量的。所以这里的拷贝操作与一般编程语言无二。</description></item><item><title>由 C++ 入门 Rust 02（隐藏）</title><link>https://fang2hou.com/post/cpp-to-rust-02/</link><pubDate>Fri, 03 Sep 2021 10:09:00 +0900</pubDate><guid>https://fang2hou.com/post/cpp-to-rust-02/</guid><description>前言 之前一篇文章，有简略的介绍 Rust 中比较有特色的语法——隐藏。在本文中将会进行一个小实验来进一步了解 Rust 变量隐藏的细节。
理解隐藏 代码 1 先看下下面这段简单的代码，函数内第二行和第三行都对变量 x 进行了隐藏，故最后输出时，x 为 yes 字符串。</description></item><item><title>由 C++ 入门 Rust 01（函数变量）</title><link>https://fang2hou.com/post/cpp-to-rust-01/</link><pubDate>Tue, 25 May 2021 13:19:20 +0900</pubDate><guid>https://fang2hou.com/post/cpp-to-rust-01/</guid><description>Rust Rust 是一款主攻编程安全的语言，其最引人注目的就是所有权概念。在该概念下你不需要费神考虑是否存在内存上的编程陷阱，大部分操作都会被 Rust 编译器自动捕获。同时，Rust 还提供了便利的垃圾回收机制。作为这几年的新起之秀，Rust 越来越被广泛的运用于日常开发之中。
本系列文章将尝试从一位 C++ 学习者的视角来掌握 Rust 中的核心概念。</description></item></channel></rss>